\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand{\bigO}[1]{\mathcal{O}(#1)}
\newcommand{\textHighlight}[1]{\textcolor{red}{#1}}

\begin{document}

\title{Practical assignment 1 \\ Algorithms \& Datastructures}
\author{Carlo Jessurun s1013793 \\ Tony Lopar s1013792}
\date{\parbox{\linewidth}{\centering%
  Nijmegen, \today\endgraf\bigskip
  Frits Vaandrager\endgraf\medskip
  2017-2018 \endgraf
  Radboud University Nijmegen}}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Explanation}
In this chapter we will explain the processes that take place in the algorithm. The algorithm can be split into multiple processes. The three main processes the algorithm performs are:
\begin{enumerate}
  \item Load and transform input
  \item Algorithm
  \item Writing output
\end{enumerate}

\subsection{Load and transform input}
The input contains a number of constellations $n$ and a matrix of $n \cdot n$. This number can be used to identify the size of the matrix and help with the import. This number may also be used to check whether the lines of the output are equal to the constellations, so we save this value in a local variable.

An example of a matrix with 4 constellations can be seen in table~\ref{table:T1}. We can see that the table is symmetric since the path between two cities may be also taken the other way. We also see that there is no path from a city to itself. This means that a half of the matrix should give enough information, so we may only import the half of the matrix.  The \textbf{stdin} in java reads lines from the start which makes reading the bottom of the matrix a better option than the top. The values that are read in this case are marked red in table~\ref{table:T1}.
\newline
\begin{table}[h]
  \begin{center}
    \begin{tabular}{c | c | c | c}
      0 & 1 & 2 & 3 \\ \hline
      \textHighlight{1} & 0 & 1 & 2 \\ \hline
      \textHighlight{2} & \textHighlight{1} & 0 & 1 \\ \hline
      \textHighlight{3} & \textHighlight{2} & \textHighlight{1} & 0
    \end{tabular}
    \caption{Example matrix} \label{table:T1}
  \end{center}
\end{table}
\vspace{-0,5cm}

For all the values that are read in the input an edge in the graph is created with the cost of the path. After the input is fully read, we have a graph with an edge between each pair of cities as result.

\newpage
\subsection{Algorithm}
\subsubsection{Building the Minimum spanning Tree}
After going through the graph building step based on the adjaceny matrix we are left with a connected and undirected graph to work with. Given that connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.
\newline
\newline
The MST step is perfect for our solution since we want the minimum amount of roads to connect the cities together. After experimenting a bit we choose to use the algorithm of Kruskal for finding the MST. Kruskals algorithm goes through the following steps to find the MST:
\begin{enumerate}
  \item Sort all the edges in non-decreasing order of their weight.
  \item Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.
  \item Repeat step 2 until there are (V-1) edges in the spanning tree.
\end{enumerate}

After doing so, we found that finding the MST is not good enough. for example in the first inputfile $``a_1.in''$ we have four cities so we expect to have four resulting edges between the cities. In our resulting MST however, we will of course find three edges. The following problem consists of finding an edge that we can add to our resulting list of edges until we have an amount of edges that is equal to the amount of cities.

\subsubsection{Fixing the last edge}
Since Kruskal results a tree graph, we will only have one path between every pair of vertices. This means we don’t meet the property of n edges in the graph, since then there should be two paths between at least one pair of vertices. This means we should add one more edge in the tree.

There may be two cases possible. The first case is that the extra edge is officially redundant and it doesn’t matter which edge we add to the output. In the case that the last edge doesn't matter we pick the next edge in the list.

The second case is that a path between two vertices is longer than it was in the input. In this case we should check which edge should be added tot he output to make the lengths of the paths correct again. After running some checks we found out that the edge we should add is the edge with the lowest weigth where the path tot he vertices is incorrect without it. All longer incorrect paths depend on this edge. In order to find out which paths are incorrect we make use of BFS to calculate the distances between edges. Since the tree has only one path between each pair of vertices, BFS will always give the shortest path.

In some cases Kruskal thrown out an edge in a circle of edges with the smallest weigth. In this situation there is no other equal path possible between the vertices, since the edge between them was the shortest possible. In this case, we save this edge to a list and add it as the last edge in the output.

\subsection{Writing output}
After running this algorithm we are left with the resulting graph with the same number of edges as there are constellations/cities. These edges are saved in an array over which we can iterate and print the edge to the sdout. In the Edge class the is a $toString$ method that is modified to print according to the guidelines.

\newpage
\section{Analysis}

\subsection{Correctness}
In this section we will discuss the Correctness of the processes.

\subsubsection{Load and transform input}
Since the edges are undirected, the graph will always be symmetric like shown in table~\ref{table:T1}. This means that only in all cases one half of the graph will contain the same information as the other, because the edge $u \to v$ is equal to the edge $v \to u$. This means that importing the half matrix gives the same info as importing the whole matrix which makes this process correct.

\subsubsection{Building the MST}
In this subsection we will look at the proof for our implementation of Kruskals algorithm which we use to find the MST. We've used the proof given by Christopher Hanusa at City University as this perfectly fits in our usecase.
\newline
\newline
\textbf{Theorem.} After running Kruskal’s algorithm on a connected weighted graph G, its output T is a
minimum weight spanning tree.
\newline
\newline
\textbf{Proof.} First, T is a spanning tree. This is because:
\begin{itemize}
  \item \textbf{T is a forest.} No cycles are ever created
  \item \textbf{T is spanning.} Suppose that there is a vertex v that is not incident with the edges of T.
Then the incident edges of v must have been considered in the algorithm at some step. The
first edge (in edge order) would have been included because it could not have created a cycle,
which contradicts the definition of T.
  \item \textbf{T is connected.} Suppose that T is not connected. Then T has two or more connected
components. Since G is connected, then these components must be connected by some edges
in G, not in T. The first of these edges (in edge order) would have been included in T because
it could not have created a cycle, which contradicts the definition of T.
\end{itemize}
Second, T is a spanning tree of minimum weight. We will prove this using induction. Let $T^1$ be a
minimum-weight spanning tree. If T = $T^1$, then T is a minimum weight spanning tree. If $T = T^1$,
then there exists an edge e $\in$ $T^1$ of minimum weight that is not in T. Further, $T \cup e$ contains a
cycle C such that:
\begin{itemize}
  \item Every edge in C has weight less than wt (e). (This follows from how the algorithm constructed
T.)
  \item There is some edge f in C that is not in $T^1$. (Because $T^1$ does not contain the cycle C.)
\end{itemize}
Consider the tree $T2 = T / {e}\cup{f}:$
\begin{itemize}
  \item $T^2$ is a spanning tree.
  \item $T^2$ has more edges in common with $T^1$ than T did.
  \item And $wt(T^2)$ $\geqq $ $wt(T)$. (We exchanged an edge for one that is no more expensive.)
\end{itemize}
We can redo the same process with $T^2$ to find a spanning tree $T^3$ with more edges in common with
$T^1$. By induction, we can continue this process until we reach $T^1$, from which we see
\newline
\newline
$wt (T) \leqq wt (T^2) \leqq wt (T^3) \leqq \cdot \cdot \cdot \leqq wt (T^1).$
\newline
\newline
Since $T^1$ is a minimum weight spanning tree, then these inequalities must be equalities and we
conclude that T is a minimum weight spanning tree.

\subsubsection{Fixing the last edge}
In this process there two possible scenarios. The first scenario is that it doesn't matter which edge we add as last edge to the graph. In this case any edge will be correct so we add the first edge on our list.

In the case that a specific edge needs to be added, we should insert the correct one. Since the MST skips an edge when a cycle is detected, we will have the scenario where kruskal misses an important edge when there's a cycle with edges of the minumum weight. So, when this happens, we store this edge and add it to the output. In the case that there was no such cycle, we should check whether the distances between two edges are correct. We will do this for the remaining edges in an incrementing order for the weigth. The reason for this is that the incorrect path with the least weight have another incorrect path as subpath, so no other edge could fix this path. In order to find the distance we make use of BFS. Since the graph is a tree structure the found paths will be the shortest paths, since it are the only paths.

\subsubsection{Writing output}
Since the algorithm already makes sure there are n edges in the list, there will be printed n lines. By modifying the $toString$ method of the Edge objects the output corresponds to the given requirements.

\newpage
\subsection{Complexity}
In this section we will give an analysis of the complex of the alorithm. We will give the complexity for each part of the alogorithm and discuss these in detail. After this, the complexity of the total algorithm following from the subprocesses will be given. The complexities for the subprocesses are as follows.
\begin{itemize}
  \item Import input $\bigO{n^2}$
  \item Algorithm $\bigO{E log E}$
  \item Fixup step $\bigO{n^2}$
  \item Writing output $O(n)$
  \item \textbf{Total algorithm $\bigO{n^2}$}
\end{itemize}

\subsubsection{Load and transform input}
The input is being imported from the \textbf{stdin}. A scanner scans the lines till they reach the value of the city to itself and skips the rest of the line. In this way only the bottom of the matrix is read. Since the number of constellations is one number this is a constrant the detailed complexity of the importing of the data is $\bigO{\frac{1}{2}n^2 - \frac{1}{2}n + 1}$. Since the first part depends on $n^2$ the complexity of the importing process is $\bigO{n^2}$.

\subsubsection{Building the MST}
We use Kruskals algorithm to build our Minimum Spanning tree. The time complexity for this build step is: $\bigO{ElogE}$ or $\bigO{ElogV}$. Sorting of edges takes $\bigO{ELogE}$ time. After sorting, we iterate through all edges and apply find-union algorithm. The find and union operations can take at most $\bigO{LogV}$ time. So overall complexity is $\bigO{ELogE + ELogV}$ time. The value of E can be atmost $\bigO{V2}$, so $\bigO{LogV}$ are $\bigO{LogE}$ same. Therefore, overall time complexity is $\bigO{ElogE}$ or $\bigO{ElogV}$

\subsubsection{Fixing the last edge}
The fixup step first saves the next edge in the list for the case it doesn't matter which edge we add. Then it checks whether there was a minimum-weight edge cycle. If so, then it adds this edge. Both operations take $\bigO{1}$, since there is only there is only one check being performed and if it's true an operation that's only performed once.

After these steps there is a check whether the paths in the tree correspond to the original paths of the matrix. In order to calculate the paths between a pair of vertices we make use of BFS. Before we execute BFS, we make sure we reset any possible results of an earlier execution. This reset has a Complexity of $\bigO{n + 1}$, since the list has a distance to other vertices.

After this reset we perform BFS. BFS self has a complexity of $\bigO{|V| + |E|}$ which is linear. However to find the adjacencies of a vertex in the mst, we iterate through all edges. These adjacencies are necessary for BFS. Because of this search the total running time of BFS-execution will be $\bigO{n \cdot (|V| + |E|)}$ which is equal to $\bigO{n^2}$.

\subsubsection{Writing output}
The complexity of writing the output is $\bigO{n}$. The array with edges will only contain $n$ elements which are iterated and printed.

\newpage
\section{Reference}

Christopher Hanusa, (2015). Proof of Kruskal’s Algorithm. \newline
http://people.qc.cuny.edu/faculty/christopher.hanusa/courses/634sp12/Documents/KruskalProof.pdf

\end{document}
